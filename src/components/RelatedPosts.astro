---
// RelatedPosts.astro - Display related blog posts based on tags or categories
import { getCollection } from 'astro:content';
import FormattedDate from './FormattedDate.astro';

const { currentPost, tags = [], limit = 3 } = Astro.props;

// Get all blog posts
const allPosts = await getCollection('blog');

// PDF-related common keywords to match posts
const pdfKeywords = ['pdf', 'security', 'share', 'link', 'view', 'limit', 'secure', 'download', 'access', 'control', 'qr', 'code'];

// Function to score post relevance
function scoreRelevance(post, tags) {
  if (!post.data.title) return 0;
  
  let score = 0;
  const title = post.data.title.toLowerCase();
  
  // Score based on matching tags/keywords
  tags.forEach(tag => {
    if (title.includes(tag.toLowerCase())) {
      score += 2; // Higher score for title matches
    }
  });
  
  // Add score for PDF-related keywords
  pdfKeywords.forEach(keyword => {
    if (title.includes(keyword)) {
      score += 1;
    }
  });
  
  return score;
}

// Extract slug from the post ID (only handle main blog folder files)
function getPostPathInfo(id) {
  if (!id) return { slug: '' };
  
  const pathParts = id.split('/');
  const filename = pathParts.pop() || '';
  const slug = filename.replace(/\.md$/, '');
  
  return { slug };
}

// Skip component if the current post is not in the main blog folder
// This component only handles files directly under /blog/, not subfolders
if (typeof currentPost === 'string' && currentPost.includes('/blog/') && currentPost.split('/').length > 3) {
  return; // Exit for posts in subfolders (cn/, fr/, etc.)
}

// Filter out the current post and get related posts
const relatedPosts = allPosts
  .filter(post => post.id !== currentPost)
  // Add path info
  .map(post => ({
    ...post,
    ...getPostPathInfo(post.id),
    relevanceScore: scoreRelevance(post, tags)
  }))
  // Only handle posts directly under /blog/, not in subfolders
  .filter(post => {
    const pathParts = post.id.split('/');
    return pathParts.length <= 3; // blog/post.md (3 parts)
  })
  // Sort by relevance score (higher first) then by date (newer first)
  .sort((a, b) => {
    if (b.relevanceScore !== a.relevanceScore) {
      return b.relevanceScore - a.relevanceScore;
    }
    return new Date(b.data.pubDate).getTime() - new Date(a.data.pubDate).getTime();
  })
  .slice(0, limit);
---

{relatedPosts.length > 0 && (
  <div class="related-posts">
    <h3 class="related-header">You Might Also Like</h3>
    <div class="related-grid">
      {relatedPosts.map(post => (
        <div class="related-post">
          <div class="related-post-content">
            <a href={`/blog/${post.slug}`} class="related-title">
              {post.data.title}
            </a>
            <div class="related-date">
              <FormattedDate date={post.data.pubDate} />
            </div>
          </div>
        </div>
      ))}
    </div>
  </div>
)}

<style>
  .related-posts {
    margin-top: 4rem;
    padding-top: 2rem;
    border-top: 1px solid #eee;
  }
  
  .related-header {
    font-size: 1.5rem;
    font-weight: 600;
    margin-bottom: 1.5rem;
    color: #333;
  }
  
  .related-grid {
    display: grid;
    grid-template-columns: repeat(auto-fill, minmax(250px, 1fr));
    gap: 1.5rem;
  }
  
  .related-post {
    background: #f8f9fa;
    border-radius: 8px;
    overflow: hidden;
    transition: transform 0.2s, box-shadow 0.2s;
  }
  
  .related-post:hover {
    transform: translateY(-5px);
    box-shadow: 0 10px 20px rgba(0,0,0,0.05);
  }
  
  .related-post-content {
    padding: 1.2rem;
  }
  
  .related-title {
    font-size: 1.1rem;
    font-weight: 600;
    color: #3498db;
    text-decoration: none;
    display: block;
    margin-bottom: 0.5rem;
    line-height: 1.4;
  }
  
  .related-date {
    font-size: 0.85rem;
    color: #666;
  }
  
  @media (max-width: 768px) {
    .related-grid {
      grid-template-columns: 1fr;
    }
  }
</style>